//! Tests that configuration generation has not changed.
//!
//! If you have changed it intentionally, run `just generate-configuration`.
//!
//! The github CI setup runs these tests subject to the filtering logic in
//! '.github/test-configuration.json'. Naming a test with the prefix 'postgres_current_only` will
//! ensure they only run on the latest version of postgres being tested. This is necessary because
//! they rely on supporting data (the chinook NDC metadata configuration) which we maintain only for
//! the latest version.

#![cfg(test)]

use crate::version3::{introspect, RawConfiguration};
use std::collections::HashMap;
use std::fmt::Write;
use std::path::Path;

use crate::common;

#[tokio::test]
async fn get_configuration_schema() {
    // TODO: have this respect the version-agnostic configuration interface?
    let schema = schemars::schema_for!(RawConfiguration);
    insta::assert_json_snapshot!(schema);
}

// version 3 tests

#[tokio::test]
async fn postgres_configuration_v3_conforms_to_the_schema() {
    configuration_conforms_to_the_schema(common::postgres::CHINOOK_NDC_METADATA_PATH)
        .await
        .unwrap();
}

#[tokio::test]
async fn citus_configuration_v3_conforms_to_the_schema() {
    configuration_conforms_to_the_schema(common::citus::CHINOOK_NDC_METADATA_PATH)
        .await
        .unwrap();
}

#[tokio::test]
async fn cockroach_configuration_v3_conforms_to_the_schema() {
    configuration_conforms_to_the_schema(common::cockroach::CHINOOK_NDC_METADATA_PATH)
        .await
        .unwrap();
}

#[tokio::test]
async fn postgres_current_only_configure_initial_configuration_is_unchanged() {
    let args = RawConfiguration::empty();
    let connection_string = common::postgres::CONNECTION_URI;
    let environment = HashMap::from([(
        crate::DEFAULT_CONNECTION_URI_VARIABLE.into(),
        connection_string.into(),
    )]);

    let default_configuration = introspect(args, environment)
        .await
        .expect("configuration::introspect");

    insta::assert_json_snapshot!(default_configuration);
}

pub async fn configuration_conforms_to_the_schema(
    chinook_ndc_metadata_path: impl AsRef<Path>,
) -> anyhow::Result<()> {
    check_value_conforms_to_schema::<RawConfiguration>(
        &read_configuration(chinook_ndc_metadata_path).await?,
    );
    Ok(())
}

async fn read_configuration(
    chinook_ndc_metadata_path: impl AsRef<Path>,
) -> anyhow::Result<serde_json::Value> {
    let absolute_configuration_directory =
        common::get_path_from_project_root(chinook_ndc_metadata_path);

    let contents =
        tokio::fs::read_to_string(absolute_configuration_directory.join("configuration.json"))
            .await?;

    Ok(serde_json::from_str(&contents)?)
}
/// Checks that a given value conforms to the schema generated by `schemars`.
///
/// Panics with a human-readable error if the value does not conform, or if the
/// schema could not be compiled.
pub fn check_value_conforms_to_schema<T: schemars::JsonSchema>(value: &serde_json::Value) {
    let schema_json = serde_json::to_value(schemars::schema_for!(T))
        .expect("the schema could not be converted to JSON");
    let schema = jsonschema::JSONSchema::options()
        .with_draft(jsonschema::Draft::Draft7)
        .compile(&schema_json)
        .expect("the schema could not be compiled");

    let result = schema.validate(value);

    match result {
        Ok(()) => (),
        Err(errors) => {
            panic!(
                "The configuration does not conform to the schema.\n{}",
                errors.fold(String::new(), |mut str, error| {
                    let _ = write!(
                        str,
                        "{}\ninstance path: {}\nschema path:   {}\n\n",
                        error, error.instance_path, error.schema_path
                    );
                    str
                })
            )
        }
    }
}
